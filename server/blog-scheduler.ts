import { BlogGeneratorService } from "./blog-generator";
import { IStorage } from "./storage";

export interface SchedulerStatus {
  isRunning: boolean;
  lastRun: Date | null;
  nextRun: Date | null;
  totalGenerated: number;
  errors: number;
}

export class BlogScheduler {
  private intervalId: NodeJS.Timeout | null = null;
  private isRunning = false;
  private status: SchedulerStatus = {
    isRunning: false,
    lastRun: null,
    nextRun: null,
    totalGenerated: 0,
    errors: 0
  };

  constructor(
    private blogGenerator: BlogGeneratorService,
    private storage: IStorage,
    private checkIntervalMinutes: number = 30 // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
  ) {}

  /**
   * –ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–¥–∞—á
   */
  start(): void {
    if (this.intervalId) {
      console.log("üìÖ Blog scheduler is already running");
      return;
    }

    console.log(`üöÄ Starting blog scheduler (checking every ${this.checkIntervalMinutes} minutes)`);
    
    this.isRunning = true;
    this.status.isRunning = true;
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞
    setTimeout(() => this.runScheduledCheck(), 60 * 1000);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    this.intervalId = setInterval(() => {
      this.runScheduledCheck();
    }, this.checkIntervalMinutes * 60 * 1000);

    console.log("‚úÖ Blog scheduler started successfully");
  }

  /**
   * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–¥–∞—á
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    
    this.isRunning = false;
    this.status.isRunning = false;
    this.status.nextRun = null;
    
    console.log("‚èπÔ∏è Blog scheduler stopped");
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
   */
  getStatus(): SchedulerStatus {
    return { ...this.status };
  }

  /**
   * –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏—é (–∏–≥–Ω–æ—Ä–∏—Ä—É—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ)
   */
  async forceGeneration(): Promise<{
    articlesGenerated: number;
    nextGenerationAt: Date | null;
    message: string;
  }> {
    console.log("üî• Force generation requested");
    
    try {
      const result = await this.blogGenerator.runScheduledGeneration();
      
      this.status.lastRun = new Date();
      this.status.totalGenerated += result.articlesGenerated;
      this.status.nextRun = result.nextGenerationAt;
      
      if (result.articlesGenerated > 0) {
        console.log(`‚úÖ Force generation completed: ${result.articlesGenerated} articles`);
      } else {
        console.log(`‚ÑπÔ∏è Force generation completed: ${result.message}`);
      }
      
      return result;
    } catch (error) {
      this.status.errors++;
      console.error("‚ùå Force generation failed:", error);
      throw error;
    }
  }

  /**
   * –í—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
   */
  private async runScheduledCheck(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    console.log("üîç Running scheduled blog generation check...");

    try {
      const result = await this.blogGenerator.runScheduledGeneration();
      
      this.status.lastRun = new Date();
      this.status.nextRun = result.nextGenerationAt;
      
      if (result.articlesGenerated > 0) {
        this.status.totalGenerated += result.articlesGenerated;
        console.log(`üì∞ Scheduled generation successful: ${result.articlesGenerated} articles created`);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤ –ª–æ–≥–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        console.log(`üìä Total articles generated by scheduler: ${this.status.totalGenerated}`);
      } else {
        console.log(`‚è∞ Scheduled check completed: ${result.message}`);
      }
      
    } catch (error) {
      this.status.errors++;
      console.error("‚ùå Scheduled generation failed:", error);
      
      // –ù–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É
      console.log("üîÑ Scheduler will continue running despite the error");
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
   */
  async getGenerationSettings(): Promise<{
    enabled: boolean;
    frequency: string;
    maxArticlesPerDay: number;
    nextScheduledRun: Date | null;
    articlesToday: number;
  }> {
    try {
      const settings = await this.storage.getBlogGenerationSettings();
      
      // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç—å–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const todayArticles = await this.storage.getAllBlogArticles({
        status: "published",
        limit: 200 // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–¥—Å—á–µ—Ç–∞
      });
      
      const articlesToday = todayArticles.filter(article => 
        article.publishedAt && article.publishedAt >= today
      ).length;

      return {
        enabled: settings?.isEnabled ?? false,
        frequency: settings?.frequency ?? "daily", 
        maxArticlesPerDay: settings?.maxArticlesPerDay ?? 3,
        nextScheduledRun: settings?.nextGenerationAt ?? null,
        articlesToday
      };
      
    } catch (error) {
      console.error("‚ùå Failed to get generation settings:", error);
      return {
        enabled: false,
        frequency: "daily",
        maxArticlesPerDay: 3,
        nextScheduledRun: null,
        articlesToday: 0
      };
    }
  }

  /**
   * –û–±–Ω–æ–≤–ª—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
   */
  async updateGenerationSettings(updates: {
    enabled?: boolean;
    frequency?: string;
    maxArticlesPerDay?: number;
  }): Promise<void> {
    try {
      await this.storage.updateBlogGenerationSettings({
        isEnabled: updates.enabled,
        frequency: updates.frequency,
        maxArticlesPerDay: updates.maxArticlesPerDay,
        updatedAt: new Date()
      });
      
      console.log("‚öôÔ∏è Generation settings updated:", updates);
    } catch (error) {
      console.error("‚ùå Failed to update generation settings:", error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–∞–±–æ—Ç—ã –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
   */
  getSchedulerStats(): {
    status: SchedulerStatus;
    uptime: string;
    checkInterval: number;
    errorRate: number;
  } {
    const uptime = this.status.lastRun 
      ? `${Math.round((Date.now() - this.status.lastRun.getTime()) / (1000 * 60))} –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥`
      : "–ï—â–µ –Ω–µ –∑–∞–ø—É—Å–∫–∞–ª—Å—è";
      
    const errorRate = this.status.totalGenerated > 0 
      ? Math.round((this.status.errors / (this.status.totalGenerated + this.status.errors)) * 100)
      : 0;

    return {
      status: this.getStatus(),
      uptime,
      checkInterval: this.checkIntervalMinutes,
      errorRate
    };
  }
}